---
title: "IAT Full Study"
date: '2023-09-07'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


For IAT Race, one participant's result was excluded : "There were too many fast trials to determine a result"


```{r}
# Copied from Elad Zlotnick (from here: https://github.com/eladzlot/minnojs-qiat/blob/master/qiat.R)
# Parse csv generated by minnoJS
#
# @param df a data frame
# @param id the column name holding the ids
# @param data the column name holding the data (we assume the data holds an array of unnested objects)
#
# @example
# qiat.parse.quoted(df, 'ResponseId', 'Q_47')
# qiat.parse(df, ResponseId, Q_47)
#
# @returns data frame with parsed data, rows with NA or '' are omitted.
qiat.parse.quoted = function(df, id, data){
  # @TODO does not work?
  # if (is.factor(df[id])) stop(paste0(data, ' column must not be a factor'))
  filteredDF = df[df[,data]!='' & !is.na(df[,data]) ,]
  
  # parse data -> list of data data frames
  csvList = lapply(filteredDF[,data], function(str) tryCatch({
    read.csv(text=str,stringsAsFactors = FALSE)
  },
  error = function(err){
    message('woa there is a malformed csv here')
    return(NA)
  }
  ))
  #browser()
  # add id to each data DF
  mask = which(sapply(csvList,nrow)>0)
  dataPages = mapply(
    function(id, df) cbind(id,df),
    filteredDF[mask,id],
    csvList[mask],
    SIMPLIFY = FALSE
  )
  
  if (!length(dataPages)) { return(data.frame()) }
  
  # concat pages
  do.call(rbind,dataPages)
}

qiat.parse = function(df, id, data){
  qiat.parse.quoted(df, deparse(substitute(id)), deparse(substitute(data)))
}
```


```{r}
#Read your file here.
df = read.csv(paste('data/survey_responses.csv',sep = '\\'))
```

```{r}
#data process
colnames(df) <- df[1,]
df <- df[-c(1,2),]
colnames(df)

```




```{r}
#The escaping in the data sometimes uses "" which we need to change to " for the parsing.
#Note IAT in my data was the columns that saved the IAT data for each participant. It might have a different name in your data. 
library(kutils)
df$IAT_Gender <- mgsub(df$`IAT Gender`, pattern = c('""'), replacement = c('"'))
df$IAT_Race <- mgsub(df$`IAT Race`, pattern = c('""'), replacement = c('"'))
```



```{r}
#Use Elad's parsing function
IAT_Gender <- qiat.parse.quoted(df = df, id='user_id', data = 'IAT_Gender')
IAT_Race <- qiat.parse.quoted(df = df, id='user_id', data = 'IAT_Race')
```

```{r}
#Sanity check: see the names of the variables.
nrow(IAT_Gender)
names(IAT_Gender)

nrow(IAT_Race)
names(IAT_Race)
#If successful, these should be:  "id"    "block" "trial" "cond"  "comp"  "type"  "cat"   "stim"  "resp"  "err"   "rt"    "d"     "fb"    "bOrd" 
```


```{r}
#Keep only the critical blocks
iat.raw.g <- IAT_Gender[which(IAT_Gender$block %in% c(3,4,6,7)),]
#Sanity check: need to include only "incompatible" and "compatible"
table(iat.raw.g$comp, exclude=NULL)
#Make sure the 'compatible' trials are indeed what you expected them to be.
table(iat.raw.g$comp, iat.raw.g$cond, exclude=NULL)


#Keep only the critical blocks
iat.raw.r <- IAT_Race[which(IAT_Race$block %in% c(3,4,6,7)),]
#Sanity check: need to include only "incompatible" and "compatible"
table(iat.raw.r$comp, exclude=NULL)
#Make sure the 'compatible' trials are indeed what you expected them to be.
table(iat.raw.r$comp, iat.raw.r$cond, exclude=NULL)
```

```{r}
#The combination of compatibility condition and block number determined the blockName for the IAT scoring function.
iat.raw.g$blockName <- ifelse(iat.raw.g$comp == 'compatible', 
                            ifelse(iat.raw.g$block %in% c(3,6), "B3", 
                                   ifelse(iat.raw.g$block %in% c(4,7), "B4", NA)), 
                            ifelse(iat.raw.g$comp == 'incompatible', 
                                   ifelse(iat.raw.g$block %in% c(3,6), "B6", 
                                          ifelse(iat.raw.g$block %in% c(4,7), "B7", NA)), NA))
#Make sure you only have B3,B4,B6, and B7 and no NAs.
table(iat.raw.g$blockName, exclude=NULL)
#Not supposed to have any NA at this point. So, if you see <NA> here, investigate why 
#(e.g., perhaps some of your data has different cond values than expected, if you changed the cond after running a few participants)
iat.raw.g <- iat.raw.g[which(!is.na(iat.raw.g$blockName)),]



iat.raw.r$blockName <- ifelse(iat.raw.r$comp == 'compatible', 
                            ifelse(iat.raw.r$block %in% c(3,6), "B3", 
                                   ifelse(iat.raw.r$block %in% c(4,7), "B4", NA)), 
                            ifelse(iat.raw.r$comp == 'incompatible', 
                                   ifelse(iat.raw.r$block %in% c(3,6), "B6", 
                                          ifelse(iat.raw.r$block %in% c(4,7), "B7", NA)), NA))
#Make sure you only have B3,B4,B6, and B7 and no NAs.
table(iat.raw.r$blockName, exclude=NULL)
#Not supposed to have any NA at this point. So, if you see <NA> here, investigate why 
#(e.g., perhaps some of your data has different cond values than expected, if you changed the cond after running a few participants)
iat.raw.r <- iat.raw.r[which(!is.na(iat.raw.r$blockName)),]

```


```{r}
#Verify that both are numbers (probably, integer)
class(iat.raw.g$rt)
class(iat.raw.g$err)

class(iat.raw.r$rt)
class(iat.raw.r$err)
```

```{r}
##Sanity check. For each participant, we expect a certain number of trials for in each block. 
##We will indicate whether the participant has the expected number of trials within each of the critical block.
library(doBy)
nTrials.long.1 <- summaryBy(formula = err ~ id + blockName, data=iat.raw.g, FUN = length)
library(reshape2)
nTrials.1 <- dcast(nTrials.long.1, id ~ blockName, value.var = 'err.length')
#You can change those number if your IAT had different numbers
library(dplyr)
nTrials.1 <- nTrials.1 %>% 
  mutate(ntrials.ok = case_when(
    nTrials.1$B3==20 & nTrials.1$B4==40 & nTrials.1$B6==20 & nTrials.1$B7==40 ~ TRUE,
    TRUE ~ FALSE
  ))
#If not all are TRUE, then you some participants are missing data
table(nTrials.1$ntrials.ok, exclude=NULL)
```

```{r}
nTrials.long.2 <- summaryBy(formula = err ~ id + blockName, data=iat.raw.r, FUN = length)
library(reshape2)
nTrials.2 <- dcast(nTrials.long.2, id ~ blockName, value.var = 'err.length')
#You can change those number if your IAT had different numbers
library(dplyr)
nTrials.2 <- nTrials.2 %>% 
  mutate(ntrials.ok = case_when(
    nTrials.2$B3==20 & nTrials.2$B4==40 & nTrials.2$B6==20 & nTrials.2$B7==40 ~ TRUE,
    TRUE ~ FALSE
  ))
#If not all are TRUE, then you some participants are missing data
table(nTrials.2$ntrials.ok, exclude=NULL)
```




```{r}
library(IAT)
iatscore.1 <- cleanIAT(iat.raw.g, block_name="blockName", 
                     trial_blocks = c("B3", "B4", "B6", "B7"), 
                     session_id="id", 
                     trial_latency="rt",
                     trial_error = "err", 
                     v_error=2, v_extreme=2, v_std=1) 
#v_error=2 means recode error latency to m+600, v_error=1 mean the standard (onset of stimuli until the correct response is pressed). v_extreme=2(current standard)=delete trial latencies < 400ms. v_std=1 (current standard), block SD is performed including error trials 

#How many participants were excluded for problematic performance?
table(iatscore.1$SUBEXCL, exclude=NULL)
#Summary of those who were not excluded.
iatscore.1[iatscore.1$SUBEXCL!=0,]

```



```{r}
iatscore.2 <- cleanIAT(iat.raw.r, block_name="blockName", 
                     trial_blocks = c("B3", "B4", "B6", "B7"), 
                     session_id="id", 
                     trial_latency="rt",
                     trial_error = "err", 
                     v_error=2, v_extreme=2, v_std=1) 
#v_error=2 means recode error latency to m+600, v_error=1 mean the standard (onset of stimuli until the correct response is pressed). v_extreme=2(current standard)=delete trial latencies < 400ms. v_std=1 (current standard), block SD is performed including error trials 

#How many participants were excluded for problematic performance?
table(iatscore.2$SUBEXCL, exclude=NULL)
#Summary of those who were not excluded.
iatscore.2[iatscore.2$SUBEXCL!=0,]

```


```{r}
##Simple graph
library(ggplot2)
iatscore.1$dummy <- ''
box_plot <- ggplot(iatscore.1, aes(x = dummy, y = IAT))
box_plot +
  geom_boxplot() +
  geom_dotplot(binaxis = 'y',
               dotsize = 0.4,
               stackdir = 'center') +
  theme_classic() + 
  stat_summary(geom = "point", fun.y = "mean", col = "black", size = 3, shape = 24, fill = "grey")+
  labs(title="IAT Gender")
iatscore.1$dummy <- NULL


iatscore.2$dummy <- ''
box_plot <- ggplot(iatscore.2, aes(x = dummy, y = IAT))
box_plot +
  geom_boxplot() +
  geom_dotplot(binaxis = 'y',
               dotsize = 0.4,
               stackdir = 'center') +
  theme_classic() + 
  stat_summary(geom = "point", fun.y = "mean", col = "black", size = 3, shape = 24, fill = "grey")+
  labs(title="IAT Race")
iatscore.2$dummy <- NULL
```


```{r}
# merge 2 IAT scores back together
IAT1 <- iatscore.1[c('id', 'IAT')]
IAT2 <- iatscore.2[c('id', 'IAT')]
IAT_compare <- merge(IAT1, IAT2, by='id')
# rename columns
IAT_compare <- IAT_compare %>% rename(IAT_Score_Gender = IAT.x, IAT_Score_Race = IAT.y)
```


```{r}
cor(IAT_compare$IAT_Score_Gender, IAT_compare$IAT_Score_Race, use = 'na.or.complete')
```


```{r}
ggplot(IAT_compare, aes(x=id)) +
  geom_point(aes(y=IAT_Score_Gender, color='Line 1') )+
  geom_point(aes(y=IAT_Score_Race, color = 'Line 2') )+
  labs(title = "IAT Comparison", x = "Response ID", y = "IAT score")+
  scale_color_manual(values = c("Line 1" = "blue", "Line 2" = "red"),
                     labels = c("IAT_Gender", "IAT_Race")) +
  theme(legend.position = "top")+
  theme_bw()
```

```{r}
IAT_final <- merge(IAT_compare, df, by.x = "id", by.y = "user_id")
IAT_final <- IAT_final[, c(0:3)] %>% rename(user_id = id)

```

```{r}
write.csv(IAT_final, 'data/IAT_score.csv', row.names = FALSE)
```

